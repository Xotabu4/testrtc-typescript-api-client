/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/tests": {
    /** <p>List all tests in your project. This function is useful if you want to iterate over your tests. A good example for that is when you want to collect all testId's in order to run them sequentially on your nightly build.</p> */
    get: operations["getTests"];
    /** <p>Create a new test.</p> */
    post: operations["createTest"];
  };
  "/tests/{testId}": {
    /** <p>Retrieve the information of a specific test.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    get: operations["findTestById"];
    /** <p>Update a test.</p> */
    put: operations["updateTest"];
    /** <p>Delete a test.</p> */
    delete: operations["deleteTest"];
  };
  "/tests/{testId}/run": {
    /** <p>Execute a specific test.</p><p>Once the test finishes, if a webhook is provided, the webhook will be called with the given input. To the input, a field called “testRunId” will be added, with the ID of the test run result.</p><p>The webhook's override can contain a list of key values of fields of the test that are overridden with specific values for this test. Fields that can be overridden are: concurrentUsers, iterations, runOptions, serviceUrl</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    post: operations["runTestById"];
  };
  "/testruns/{testRunId}": {
    /** <p>Retrieve test run information.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    get: operations["retrieveTestRunById"];
  };
  "/testruns/externalValue/{session_name}": {
    /** Set test external value to be used with NightWatch script command rtcWaitForExternalValue */
    post: operations["setTestRunExternalValue"];
  };
  "/testagents/{testAgentId}": {
    /** <p>Retrieve report of a specific test agent information.</p><p>Each test run result is constructed out of the number of test agents used for running the test. This API retrieves the information from one specific test agent within a test run.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    get: operations["retrieveTestAgentById"];
  };
  "/testagents/{testAgentId}/files": {
    /** <p>Get the test agent file</p> */
    get: operations["getTestAgentFile"];
    /** <p>Post file which will be uploaded to the test agent as part of results</p> */
    post: operations["uploadFileToTestAgent"];
  };
  "/networktest/{id}": {};
  "/networktest-report/{id}": {};
  "/assets": {
    /** <p>List all assets in your project.</p> */
    get: operations["getAssets"];
    /** <p>Create a new asset within your project. Assets are files that can be used by your scripts. The current supported assets are scripts that can be included from your test scripts.</p><p>The asset_type must be set to 'Code'.</p> */
    post: operations["createAsset"];
  };
  "/assets/{assetId}": {
    /** <p>Get asset by id.</p> */
    get: operations["getAsset"];
    /** <p>Update an asset within your project.</p> */
    put: operations["updateAsset"];
    /** <p>Delete an asset within your project.</p> */
    delete: operations["deleteAssetById"];
  };
  "/testagents/{testAgentId}/screenshots": {
    /** <p>Get the screenshots taken for a specific probe (=test run agent) used in a test or a monitor execution.</p> */
    get: operations["getScreenshots"];
  };
  "/qualityrtc/result/{id}": {
    /** <p>Get result of network test.</p> */
    get: operations["getQualityRtcResult"];
  };
  "/qualityrtc/invite": {
    /** <p>Create qualityRTC Invite</p> */
    post: operations["createQualityRtcInvite"];
  };
  "/watchrtc/highlights": {
    /** <p>watchRTC Highlights</p> */
    post: operations["watchrtcHighlights"];
  };
  "/watchrtc/room/{rtcRoomId}/peer/{rtcPeerId}/user-rating": {
    /** <p>Set the user's rating on a given session.</p><p>If you are using the same roomId for multiple sessions then the user rating will be set only to the last time the roomId was used. */
    put: operations["watchrtcSetUserRating"];
  };
  "/watchrtc/room/{roomId}/peer/{peerId}/keys": {
    /** <p>Add keys to a session of a specific peer inside a room.</p><p>If you are using the same roomId for multiple sessions then the keys will be added only to the last time the roomId was used.</p> */
    put: operations["watchrtcAddKeys"];
  };
  "/analyzertc/upload": {
    /** <p>Upload dump file to get analyzeRTC result.</p> */
    post: operations["uploadAnalyzeDump"];
  };
  "/ip-ranges": {
    /** <p>Get GCP IP address ranges.</p> */
    get: operations["getGCPIPRangesInfo"];
  };
}

export interface definitions {
  /** @description A Monitors holds all the configurations for monitoring text execution. */
  Monitor: {
    /** @description A verbose description for the monitor. */
    info?: string;
    /** @description Should monitor be activated. */
    active: boolean;
    /** @description Id of test for which monitor is creating. */
    executeTest: string;
    /**
     * @description Scheduling for monitor.
     * h - Once an hour
     * d - Once a day
     * 30 - every 30 min ( 15, 5 )
     * c - cron expression, scheduleCron needed
     */
    scheduleMode?: string;
    /** @description Schedule cron */
    scheduleCron?: string;
  };
  /** @description A Monitor status field */
  MonitorStatus: {
    /** @description Monitor status */
    status: boolean;
  };
  /** @description An array holds all the necessary tests that can be executed in testRTC */
  Tests: definitions["TestMinimized"][];
  /** @description A Test holds all the necessary elements that hold a test that can be executed in testRTC */
  Test: {
    /** @description The readable name given to the test ( required for creation ) */
    name?: string;
    /** @description A verbose description for the test */
    info?: string;
    /** @description The tagged run options configured for this test */
    runOptions?: string;
    /** @description Started */
    stared?: boolean;
    /** @description The test script itself */
    testScript?: string;
    /** @description The SERVICE_URL configured for this test */
    serviceUrl?: string;
    /** @description Webhook object */
    webhook?: string;
    /** @description Session size */
    sessionSize?: number;
    /** @description The indicator is SERVICE_URL open */
    serviceUrlOpen?: boolean;
    /** @description Parameters for test ( required for creation ) */
    parameters?: {
      /** @description The number of concurrent users */
      concurrentUsers?: number;
    };
    testProfiles?: definitions["TestProfile"][];
  };
  /** @description A Test holds all the necessary elements that hold a test that can be executed in testRTC */
  TestMinimized: {
    /** @description The unique index given to the test */
    id?: string;
    /** @description The readable name given to the test */
    name: string;
    /** @description A verbose description for the test */
    info?: string;
    /** @description The tagged run options configured for this test */
    runOptions?: string;
    /** @description The test script itself */
    testScript?: string;
    /** @description Webhook object */
    webhook?: string;
    /** @description Session size */
    sessionSize?: number;
    testProfiles?: definitions["TestProfile"][];
    /** @description The SERVICE_URL configured for this test */
    serviceUrl?: string;
    /** @description Parameters for test */
    parameters: {
      /** @description The number of concurrent users */
      concurrentUsers?: number;
    };
  };
  /** @description Test profile object. */
  TestProfile: {
    /** @description testProfile */
    media?: string;
    /** @description Type of firewall */
    firewall?: string;
    /** @description Network connection */
    network?: string;
    /** @description Test location */
    location?: string;
    /** @description Browser for the test. */
    browser?: string;
  };
  /** @description TBD */
  TestRunParameters: {
    /** @description <p>A list of key values of fields of the test that are overridden with specific values for this test. Fields that can be overridden are:</p><ul><li>concurrentUsers</li><li>iterations</li><li>runOptions</li><li>serviceUrl</li></ul> */
    executionParameters?: {
      /**
       * Format: int32
       * @description The number of concurrent browser agents used in this test run
       */
      concurrentUsers?: number;
      /**
       * Format: int32
       * @description The session size used in this test run
       */
      sessionSize?: number;
    };
    /** @description A list of environment variables to add to the test execution. These will be accessible through process.env. */
    environmentVariables?: definitions["EnvironmentVariable"][];
    /** @description A list of machine profiles used to run a TestAgents */
    machineProfiles?: definitions["MachineProfile"][];
  };
  /** @description A key value pair of a variable and its value */
  EnvironmentVariable: {
    /** @description The variable's name */
    variable?: string;
    /** @description The variable's value */
    value?: string;
  };
  /** @description Machine profile for the test */
  MachineProfile: {
    /** @description The browser used for the test */
    browser: string;
    /** @description The data center used for the test */
    location: string;
    /** @description The network profile used by the test */
    network: string;
    /** @description The firewall profile used by the test */
    firewall: string;
    /** @description The media file used by this test */
    media: string;
  };
  /** @description A TestRun object holds a specific test execution info with detailed stats (if detailed = true) */
  TestRun: {
    /** @description The unique identifier of the TestRun object. Used as the key to access a test execution. */
    testRunId?: string;
    /** @description The unique identifier of the Test object. */
    testId?: string;
    /** @description The readable name given to the test. */
    testName?: string;
    /** @description A random name given to this test run, as a readable alternative to the testRunId */
    runName?: string;
    /** @description The result status of the test. Can be 'success', 'warnings' or 'failure' */
    status?: string;
    /** @description Can be either 'test' or 'monitor' */
    runType?: string;
    /**
     * Format: int32
     * @description The number of concurrent browser probes used in this test run
     */
    concurrentUsers?: number;
    /**
     * Format: int32
     * @description The number of browser probes, finished with 'completed' or 'warnings' status in this test execution
     */
    succeedProbes?: number;
    /**
     * Format: int32
     * @description The number of probes placed per session in this test run
     */
    sessionSize?: number;
    /**
     * Format: ISOString
     * @description The starting time of test execution (UTC format)
     */
    startTime?: string;
    /**
     * Format: int32
     * @description The duration of the test from the moment the probes spawned the browsers until logs were collected at the end of the test (in seconds)
     */
    testDuration?: number;
    /** @description The list of unique test probes used in the given test execution. This can either be ID values or expanded TestAgent objects, depending on which API call was made and what parameters was passed to it. */
    agents?: string[];
    /** @description An array of custom metrics added by the customer to this probe's test results */
    customMetrics?: definitions["CustomMetrics"][];
    /** @description URL of this test result */
    url?: string;
    stats?: definitions["TestRunStats"];
  };
  /** @description A TestAgent object holds a specific browser probe info with detailed stats (if detailed = true) that was used in a given TestRun */
  TestAgent: {
    /** @description The unique identifier of a test probe used in a test run. This value is unique across the testRTC service */
    testAgentId?: string;
    /** @description The unique identifier of the TestRun this test probe was used in */
    testRunId?: string;
    /** @description The unique identifier of the Test that was executed by this probe */
    testId?: string;
    /** @description The result status of the test. Can be 'success', 'warning' or 'failure' */
    status?: string;
    /**
     * Format: int32
     * @description The index of this probe within the test run. Starts from 1
     */
    agentIdx?: number;
    /**
     * Format: int32
     * @description The index of this probe's session within the test run. Starts from 1
     */
    sessionIdx?: number;
    /**
     * Format: int32
     * @description The index of this probe within the session. Starts from 1
     */
    inSessionIdx?: number;
    /** @description The type of the machine used by this test probe */
    machine?: string;
    /** @description The operating system used by this test probe */
    os?: string;
    /** @description The browser used by this test probe */
    browser?: {
      /** @description The name of the browser used */
      name: string;
      /** @description The exact browser version used */
      version: string;
    };
    /** @description The data center this test probe was running from */
    location?: string;
    /** @description The network profile used by this test probe */
    networkProfile?: string;
    /** @description The firewall profile used by this test probe */
    firewallProfile?: string;
    /** @description The media file used by this test probe */
    mediaFile?: string;
    /**
     * Format: ISOString
     * @description The starting time of the test execution (UTC format)
     */
    testStartTime?: string;
    /**
     * Format: int32
     * @description The total duration of the test run (in seconds)
     */
    testDuration?: number;
    /**
     * Format: ISOString
     * @description The time of first communication channel was opened (UTC format)
     */
    connectionStartTime?: string;
    /**
     * Format: int32
     * @description The total time communication channels were open (in seconds)
     */
    connectionDuration?: number;
    /** @description An array of custom metrics added by the customer to this probe's test results */
    customMetrics?: definitions["CustomMetrics"][];
    /** @description Channels created in this test run */
    channels?: definitions["Channels"][];
    textError?: string;
    rtcSetAdditionalInfo?: { [key: string]: unknown };
    /** @description Total amount of warnings */
    warnings?: number;
    /** @description Total amount of errors */
    errors?: number;
    stats?: definitions["TestAgentStats"];
  };
  /** @description Additional information about the test execution. <b>performance</b> includes average maximal, average minimal and average values for performance data across all browser agents, used in a given TestRun */
  TestRunStats: {
    /** @description Overall quality score of the test run (between 0-10; -1 if not calculated) */
    score?: number;
    /** @description The average call setup time across all probes in the test run (in milliseconds) */
    callSetupTime?: number;
    performance?: definitions["PerformanceStats"];
    /** @description Audio performance metrics, averaged across all probes in the test run */
    audio?: {
      recv?: definitions["MediaStats"];
      send?: definitions["MediaStats"];
    };
    /** @description Video performance metrics, averaged across all probes in the test run */
    video?: {
      recv?: definitions["MediaStats"];
      send?: definitions["MediaStats"];
    };
  };
  /** @description Additional information about the TestAgent. <b>performance</b> includes maximal, minimal and average values for performance data of specific browser agent */
  TestAgentStats: {
    /** @description Overall quality score of the test probe (between 0-10; -1 if not calculated) */
    score?: number;
    /** @description The time it took to connect the session. This is measured from the first setLocalDescription until the connected state (in milliseconds) */
    callSetupTime?: number;
    performance?: definitions["PerformanceStats"];
    /** @description Audio data metrics */
    audio?: {
      recv?: definitions["MediaStats"];
      send?: definitions["MediaStats"];
    };
    /** @description Video data metrics.<br/> Weighted average for FPS across all video channels */
    video?: {
      recv?: definitions["MediaStats"];
      send?: definitions["MediaStats"];
    };
  };
  MediaStats: {
    /** @description Average bitrate (in bits) */
    bitrate?: number;
    /** @description Average packets loss (0.015 = 1.51%) */
    packetLoss?: number;
    /** @description Average jitter (in milliseconds) */
    jitter?: number;
    /** @description Average round trip time (provided only for outgoing channels, in milliseconds) */
    rtt?: number;
    /** @description Average frame rate (provided only for video channels) */
    fps?: number;
  };
  PerformanceStats: {
    /** @description CPU used by the browser (in %) */
    browserCpu?: {
      max?: number;
      avg?: number;
      min?: number;
    };
    /** @description Memory used by the browser (in MBytes) */
    browserMemory?: {
      max?: number;
      avg?: number;
      min?: number;
    };
    /** @description CPU used by the probe (in %) */
    probeCpu?: {
      max?: number;
      avg?: number;
      min?: number;
    };
    /** @description Memory used by the probe (in %) */
    probeMemory?: {
      max?: number;
      avg?: number;
      min?: number;
    };
    /** @description Memory used by the probe (in MBytes) */
    probeMemoryMb?: {
      max?: number;
      avg?: number;
      min?: number;
    };
  };
  /** @description A custom metric value, provided by the customer */
  CustomMetrics: {
    /** @description The customer-given name for the metric. This is used as a unique identifier when aggregating metric values across a test run */
    name: string;
    /** @description The value of the custom metric */
    value: string;
  };
  /** @description A media channel in an agent's test run */
  Channels: {
    /** @description The name of the channel. Usually this would be the SSRC generated by the browser for the channel, if it is available */
    name: string;
    /** @description Can be either 'in' or 'out' */
    direction: string;
    /** @description Can be either 'audio' or 'video' */
    type: string;
    /** @description The audio or video codec used in the channel */
    codec?: string;
  };
  TestRunId: {
    testRunId: string;
  };
  AnalyzeResultId: {
    analyzeResultId: string;
  };
  TestDefinitionId: {
    testDefinitionId: string;
  };
  WatchrtcHighlightsRes: {
    sessions: string;
    connections: string;
    minutes: number;
    duration: string;
    participants: number;
    metrics: {
      score: number;
      mos: number;
      bitrateRecv: number;
      bitrateSend: number;
      packetLossRecv: number;
      packetLossSend: number;
      rttSend: number;
      rttRecv: number;
    } & {
      rating: unknown;
    };
  };
  WatchrtcInternalRoomIdRes: {
    internalId: string;
    url: string;
  };
  WatchrtcInternalPeerIdRes: {
    internalPeerId: string;
    peerUrl: string;
    internalRoomId: string;
    roomUrl: string;
  };
  OperationStatusRes: {
    result: string;
  };
  Error: {
    /** Format: int32 */
    code: number;
    message: string;
  };
  BlobUploadResult: {
    fullBlobName: string;
  };
  /** @description GetStats data collected during remote test execution (via SDK) */
  GetStatsChunk: {
    /** @description GetStats data */
    data: { [key: string]: unknown };
    /** @description Indicates that the test run should be finalized after this chunk of data */
    isLastChunk?: boolean;
  };
  /** @description Remote test execution options */
  RemoteTestOptions: {
    /** @description Test name */
    name: string;
  };
  /** @description Network test config */
  NetworkTestConfig: { [key: string]: unknown };
  /** @description An Asset. */
  Asset: {
    /** @description The uniq and readable name given to the asset. */
    name: string;
    /** @description An asset type. */
    asset_type?: string;
    /** @description An asset description. */
    description?: string;
    /** @description Code of asset. */
    code?: string;
    /** @description Version of asset. */
    version: string;
  };
  /** @description An array holds all the assets */
  Assets: definitions["Asset"][];
  AssetId: {
    assetId: string;
  };
  /** @description Screenshot */
  Screenshot: {
    /** @description Url of screenshot. */
    url?: string;
    /** @description Screenshot name. */
    name?: string;
    /** @description Contains time when screenshot was taken and URL of the image itself. */
    metadata?: {
      /** @description Image URL. */
      url?: string;
      /** @description Time when screenshot was taken */
      timestamp?: string;
    };
  };
  /** @description Object holds property that holds array of screenshots */
  ScreenshotsResponse: {
    /** @description An array that holds screenshots */
    screens?: definitions["Screenshot"][];
  };
  /** @description Dial In results */
  DialInData: {
    /** @description callDuration */
    callDuration: number;
    /** @description waitTime */
    waitTime: number;
    /** @description pinCode */
    pinCode: string;
    /** @description promptTime */
    promptTime: number;
    /** @description mediaUrl */
    mediaUrl: string;
    /** @description toLocation */
    toLocation: string;
    /** @description fromLocation */
    fromLocation: string;
    /** @description account */
    account: string;
  };
  MonitorResultsResponse: {
    testRunIds?: string[];
  };
  String: string;
  /** @description Last monitor run info */
  LastRunStatus: {
    id?: string;
    timestamp?: string;
    status?: string;
  };
  /** @description QualityRTC Invite model */
  QualityRTCInviteRequest: {
    name: string;
    /**
     * Format: Date
     * @description Date format should be as following: YYYY-MM-DD or YYYY-MM-DD HH-mm
     */
    expiration: string;
    /** @description JSON string object: https://testrtc.com/docs/invite-options-in-qualityrtc/ */
    options?: {
      /** @description JSON object which contains additional fields objects */
      fields?: { [key: string]: unknown }[];
    };
    numberOfTests: number;
  };
  QualityRTCInviteId: {
    inviteId: string;
  };
  /** @description Key and value object */
  KeyValObj: {
    key?: string;
    value?: string;
  };
  WatchrtcSetUserRating: {
    /** @description The user's rating. A number between 1 to 5, where 1 is bad and 5 is great. If you are using a like/don't like rating system use only values 1 and 5. */
    rating: number;
    /** @description Optional textual comment explaining the user's rating. */
    comment?: string;
  };
  /** @description Example: {key1: 'value1', key2: 'value2'} */
  WatchrtcAddKeys: { [key: string]: unknown };
  WatchrtcFilterKey: {
    key: string;
    value: string[];
  };
  WatchrtcFilter: {
    /**
     * Format: Date
     * @description Date format should be as following: YYYY-MM-DD (gets the start of a day)
     */
    startDate: string;
    /**
     * Format: Date
     * @description Date format should be as following: YYYY-MM-DD (gets the end of a day)
     */
    endDate: string;
    /** @description Clients timezone offset integer value represented in hours. Example: new Date().getTimezoneOffset() / 60 */
    timezoneOffset?: number;
    keys?: definitions["WatchrtcFilterKey"][];
  };
}

export interface operations {
  /** <p>List all tests in your project. This function is useful if you want to iterate over your tests. A good example for that is when you want to collect all testId's in order to run them sequentially on your nightly build.</p> */
  getTests: {
    responses: {
      /** tests response */
      200: {
        schema: definitions["Tests"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Create a new test.</p> */
  createTest: {
    parameters: {
      body: {
        /** Test object */
        test: definitions["Test"];
      };
    };
    responses: {
      /** Test created */
      200: {
        schema: definitions["Test"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Retrieve the information of a specific test.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  findTestById: {
    parameters: {
      path: {
        /** ID of the test to fetch */
        testId: string;
      };
    };
    responses: {
      /** Test response */
      200: {
        schema: definitions["TestMinimized"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Update a test.</p> */
  updateTest: {
    parameters: {
      path: {
        /** ID of the test to update */
        testId: string;
      };
      body: {
        /** Metrics to update */
        test: definitions["Test"];
      };
    };
    responses: {
      /** Test created */
      200: {
        schema: definitions["Test"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Delete a test.</p> */
  deleteTest: {
    parameters: {
      path: {
        /** ID of the test to delete */
        testId: string;
      };
    };
    responses: {
      /** Test Deleted */
      200: {
        schema: definitions["TestDefinitionId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Execute a specific test.</p><p>Once the test finishes, if a webhook is provided, the webhook will be called with the given input. To the input, a field called “testRunId” will be added, with the ID of the test run result.</p><p>The webhook's override can contain a list of key values of fields of the test that are overridden with specific values for this test. Fields that can be overridden are: concurrentUsers, iterations, runOptions, serviceUrl</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  runTestById: {
    parameters: {
      path: {
        /** ID of the test to fetch */
        testId: string;
      };
      body: {
        /** TestRunParameters */
        parameters?: definitions["TestRunParameters"];
      };
    };
    responses: {
      /** Test response */
      200: {
        schema: definitions["TestRunId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Retrieve test run information.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  retrieveTestRunById: {
    parameters: {
      path: {
        /** ID of the test run to fetch */
        testRunId: string;
      };
      query: {
        /** <p>If set to <b>true</b>, <b>stats</b> object will appear in response JSON.</p> */
        detailed?: boolean;
      };
    };
    responses: {
      /** TestRun response */
      200: {
        schema: definitions["TestRun"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** Set test external value to be used with NightWatch script command rtcWaitForExternalValue */
  setTestRunExternalValue: {
    parameters: {
      path: {
        /** RTC Session Name */
        session_name: string;
      };
      body: {
        /** External value to set */
        external_value: definitions["KeyValObj"];
      };
    };
    responses: {
      /** success update */
      200: unknown;
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Retrieve report of a specific test agent information.</p><p>Each test run result is constructed out of the number of test agents used for running the test. This API retrieves the information from one specific test agent within a test run.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  retrieveTestAgentById: {
    parameters: {
      path: {
        /** ID of the test agent to fetch */
        testAgentId: string;
      };
      query: {
        /** <p>If set to <b>true</b>, <b>stats</b> object will appear in response JSON.</p> */
        detailed?: boolean;
      };
    };
    responses: {
      /** TestAgent response */
      200: {
        schema: definitions["TestAgent"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get the test agent file</p> */
  getTestAgentFile: {
    parameters: {
      path: {
        /** ID of the test agent to fetch */
        testAgentId: string;
      };
      query: {
        /** browser_logs | webrtc_internals_dump | getstat_logs | nightwatch_log */
        filename: string;
      };
    };
    responses: {
      /** Test agent file */
      200: {
        schema: { [key: string]: unknown };
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Test iteration has no log file or not found */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Post file which will be uploaded to the test agent as part of results</p> */
  uploadFileToTestAgent: {
    parameters: {
      path: {
        /** ID of the test agent to fetch */
        testAgentId: string;
      };
      formData: {
        /** The file to upload ( <b>.txt</b> or <b>.json</b> ). */
        file?: unknown;
      };
      query: {
        /**
         * File name without extension (.txt). Please avoid usage:
         * <pre>':','?', '#', '[', ']', '\', '/', '.'</pre>
         */
        filename?: string;
      };
    };
    responses: {
      /** update response */
      200: {
        schema: definitions["CustomMetrics"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>List all assets in your project.</p> */
  getAssets: {
    responses: {
      /** assets response */
      200: {
        schema: definitions["Assets"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Create a new asset within your project. Assets are files that can be used by your scripts. The current supported assets are scripts that can be included from your test scripts.</p><p>The asset_type must be set to 'Code'.</p> */
  createAsset: {
    parameters: {
      body: {
        /** Asset to create */
        asset: definitions["Asset"];
      };
    };
    responses: {
      /** Asset created */
      201: {
        schema: definitions["AssetId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Bad request - Invalid parameters supplied */
      409: {
        schema: definitions["Error"];
      };
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get asset by id.</p> */
  getAsset: {
    parameters: {
      path: {
        /** ID of the previously saved asset */
        assetId: string;
      };
    };
    responses: {
      /** Asset results */
      200: {
        schema: definitions["Asset"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Update an asset within your project.</p> */
  updateAsset: {
    parameters: {
      path: {
        /** ID of the asset to update */
        assetId: string;
      };
      body: {
        /** Asset to update */
        asset: definitions["Asset"];
      };
    };
    responses: {
      /** Asset updated */
      200: {
        schema: definitions["Asset"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Bad request - Invalid parameters supplied */
      409: {
        schema: definitions["Error"];
      };
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Delete an asset within your project.</p> */
  deleteAssetById: {
    parameters: {
      path: {
        /** ID of the asset to delete */
        assetId: string;
      };
    };
    responses: {
      /** Asset Deleted */
      200: {
        schema: definitions["AssetId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get the screenshots taken for a specific probe (=test run agent) used in a test or a monitor execution.</p> */
  getScreenshots: {
    parameters: {
      path: {
        /** ID of the test iteration */
        testAgentId: string;
      };
    };
    responses: {
      /** List of screenshots */
      200: {
        schema: definitions["ScreenshotsResponse"];
      };
      /** Bad request */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get result of network test.</p> */
  getQualityRtcResult: {
    parameters: {
      path: {
        /** ID of the previously saved network test */
        id: string;
      };
    };
    responses: {
      /** Network test results */
      200: {
        schema: { [key: string]: unknown };
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Create qualityRTC Invite</p> */
  createQualityRtcInvite: {
    parameters: {
      body: {
        /** QualityRTC Invite to create */
        invite: definitions["QualityRTCInviteRequest"];
      };
    };
    responses: {
      /** QualityRTC Invite Created */
      200: {
        schema: definitions["QualityRTCInviteId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>watchRTC Highlights</p> */
  watchrtcHighlights: {
    parameters: {
      body: {
        /** Filter data */
        filterData: definitions["WatchrtcFilter"];
      };
    };
    responses: {
      /** Highlights */
      200: {
        schema: definitions["WatchrtcHighlightsRes"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Set the user's rating on a given session.</p><p>If you are using the same roomId for multiple sessions then the user rating will be set only to the last time the roomId was used. */
  watchrtcSetUserRating: {
    parameters: {
      path: {
        /** The rtcRoomId the user rating is associated with. */
        rtcRoomId: string;
        /** The rtcPeerId of the user who provided his rating. */
        rtcPeerId: string;
      };
      body: {
        data: definitions["WatchrtcSetUserRating"];
      };
    };
    responses: {
      200: {
        schema: definitions["OperationStatusRes"];
      };
      /** Bad request */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Add keys to a session of a specific peer inside a room.</p><p>If you are using the same roomId for multiple sessions then the keys will be added only to the last time the roomId was used.</p> */
  watchrtcAddKeys: {
    parameters: {
      path: {
        /** The roomId the keys are associated with. */
        roomId: string;
        /** The peerId of the user who has these keys. */
        peerId: string;
      };
      body: {
        data: definitions["WatchrtcAddKeys"];
      };
    };
    responses: {
      200: {
        schema: definitions["OperationStatusRes"];
      };
      /** Bad request */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Upload dump file to get analyzeRTC result.</p> */
  uploadAnalyzeDump: {
    parameters: {
      formData: {
        /** Dump file to analyze ( <b>.txt</b> or <b>.json</b> ) */
        file: unknown;
      };
      query: {
        /**
         * Optional file name without extension ( .txt, .json ). Please avoid usage:
         * <pre>':','?', '#', '[', ']', '\', '/', '.'</pre>
         */
        fileName?: string;
      };
    };
    responses: {
      /** Dump file analyze result ID */
      200: {
        schema: definitions["AnalyzeResultId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - Resource does not exist */
      404: unknown;
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get GCP IP address ranges.</p> */
  getGCPIPRangesInfo: {
    responses: {
      /** Success */
      200: {
        schema: {
          /** Format: date-time */
          created?: string;
          /** @example Google Cloud */
          service?: string;
          ranges?: {
            "zone-name"?: {
              ipv4Prefixes?: string[];
              ipv6Prefixes?: string[];
            };
          };
        };
      };
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
}

export interface external {}
