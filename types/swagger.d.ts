/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/tests": {
    /** <p>List all tests in your project. This function is useful if you want to iterate overyour tests. A good example for that is when you want to collect all testId's in order to run them sequentially on your nightly build.</p> */
    get: operations["getTests"];
    /** <p>Create a new test.</p> */
    post: operations["createTest"];
  };
  "/tests/{testId}": {
    /** <p>Retrieve the information of a specific test.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    get: operations["findTestById"];
    /** <p>Update a new test.</p> */
    put: operations["updateTest"];
    /** <p>Delete a test.</p> */
    delete: operations["deleteTest"];
  };
  "/tests/{testId}/run": {
    /** <p>Execute a specific test.</p><p>Once the test finishes, if a webhook is provided, the webhook will be called with the given input. To the input, a field called “testRunId” will be added, with the ID of the test run result.</p><p>The webhook's override can contain a list of key values of fields of the test that are overridden with specific values for this test. Fields that can be overridden are: concurrentUsers, iterations, runOptions, serviceUrl</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    post: operations["runTestById"];
  };
  "/testruns/{testRunId}": {
    /** <p>Retrieve test run information.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    get: operations["retrieveTestRunById"];
  };
  "/testagents/{testAgentId}": {
    /** <p>Retrieve report of a specific test agent information.</p><p>Each test run result is constructed out of the number of test agents used for running the test. This API retrieves the information from one specific test agent within a test run.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
    get: operations["retrieveTestAgentById"];
  };
  "/testagents/{testAgentId}/files": {
    /** <p>Get the test agent file</p> */
    get: operations["getTestAgentFile"];
    /** <p>Post file which will be uploaded to the test agent as part of results</p> */
    post: operations["uploadFileToTestAgent"];
  };
  "/monitors/": {
    /** <p>Create a new monitor.</p> */
    post: operations["createMonitor"];
  };
  "/monitors/{monitorId}/status": {
    /** <p>Update a monitor.</p> */
    put: operations["updateMonitorStatus"];
  };
  "/networktest/{id}": {};
  "/assets": {
    /** <p>List all assets in your project.</p> */
    get: operations["getAssets"];
    /** <p>Create a new asset within your project. Assets are files that can be used by your scripts. The current supported assets are scripts that can be included from your test scripts.</p><p>The asset_type must be set to 'Code'.</p> */
    post: operations["createAsset"];
  };
  "/assets/{assetId}": {
    /** <p>Get asset by id.</p> */
    get: operations["getAsset"];
    /** <p>Update an asset within your project.</p> */
    put: operations["updateAsset"];
    /** <p>Delete an asset within your project.</p> */
    delete: operations["deleteAssetById"];
  };
  "/testagents/{testAgentId}/screenshots": {
    /** <p>Get the screenshots taken for a specific probe (=test run agent) used in a test or a monitor execution.</p> */
    get: operations["getScreenshots"];
  };
  "/dial-in": {
    /** <p>Dial In.</p> */
    post: operations["dialIn"];
  };
  "/usage": {
    /** <p>Get usage.</p> */
    get: operations["getUsage"];
  };
}

export interface definitions {
  EncodedPassword: {
    encodedPass?: number[];
  };
  /** A Monitors holds all the configurations for monitoring text execution. */
  Monitor: {
    /** A verbose description for the monitor. */
    info?: string;
    /** Should monitor be activated. */
    active: boolean;
    /** Id of test for which monitor is creating. */
    executeTest: string;
    /** Scheduling for monitor. */
    scheduleMode?: string;
    /** Schedule cron */
    scheduleCron?: string;
  };
  /** A Monitor status field */
  MonitorStatus: {
    /** Monitor status */
    status: boolean;
  };
  /** A Status page object includes detailed information about service status. */
  StatusPage: {
    /** The role of current environment */
    role?: {
      /** The value which indicates does current environment have role 'web' */
      web?: boolean;
      /** The value which indicates does current environment have role 'monitor' */
      monitor?: boolean;
      /** The value which indicates does current environment have role 'batchexec' */
      batchexec?: boolean;
      /** The value which indicates does current environment have role 'remoteWorker' */
      remoteWorker?: boolean;
      /** The value which indicates does current environment have role 'api' */
      api?: boolean;
    };
    /** The configuration of current environment */
    config?: {
      /** The current version */
      version?: string;
      /** The version of agent */
      agentVersion?: string;
      /** The system name of environment */
      systemName?: string;
      /** The name of instance */
      instanceName?: string;
    };
    /** The status of queue */
    queueStatus?: string;
    /** The queue count */
    queueCount?: number;
    /** The queue status */
    dbStatus?: string;
    /** The database count */
    dbCount?: number;
    /** The status of service, indicates working status. */
    status?: string;
  };
  /** An array holds all the necessary tests that can be executed in testRTC */
  Tests: definitions["TestMinimized"][];
  /** A Test holds all the necessary elements that hold a test that can be executed in testRTC */
  Test: {
    /** The readable name given to the test */
    name: string;
    /** A verbose description for the test */
    info?: string;
    /** The tagged run options configured for this test */
    runOptions?: string;
    /** Started */
    stared?: boolean;
    /** The test script itself */
    testScript?: string;
    /** The SERVICE_URL configured for this test */
    serviceUrl?: string;
    /** The inicator is SERVICE_URL open */
    serviceUrlOpen?: boolean;
    /** The browser type. */
    browserType?: string;
    /** The browser version */
    browserVersion?: string;
    /** Parameters for test */
    parameters: {
      /** The duration of test */
      duration?: number;
      /** The number of concurrent users */
      concurrentUsers?: number;
    };
    testProfiles?: definitions["TestProfile"][];
  };
  /** A Test holds all the necessary elements that hold a test that can be executed in testRTC */
  TestMinimized: {
    /** The readable name given to the test */
    name: string;
    /** A verbose description for the test */
    info?: string;
    /** The tagged run options configured for this test */
    runOptions?: string;
    /** The test script itself */
    testScript?: string;
    /** The SERVICE_URL configured for this test */
    serviceUrl?: string;
    /** Parameters for test */
    parameters: {
      /** The number of concurrent users */
      concurrentUsers?: number;
    };
  };
  /** Test profile object. */
  TestProfile: {
    /** testProfile */
    media?: string;
    /** Type of firewall */
    firewall?: string;
    /** Network connection */
    network?: string;
    /** Test location */
    location?: string;
    /** Browser for the test. */
    browser?: string;
  };
  /** TBD */
  TestRunParameters: {
    /** <p>A list of key values of fields of the test that are overridden with specific values for this test. Fields that can be overridden are:</p><ul><li>concurrentUsers</li><li>iterations</li><li>runOptions</li><li>serviceUrl</li></ul> */
    executionParameters?: {
      /** The number of concurrent browser agents used in this test run */
      concurrentUsers?: number;
      /** The session size used in this test run */
      sessionSize?: number;
    };
    /** A list of environment variables to add to the test execution. These will be accessible through process.env. */
    environmentVariables?: definitions["EnvironmentVariable"][];
    /** A list of machine profiles used to run a testagents */
    machineProfiles?: definitions["MachineProfile"][];
  };
  /** A key value pair of a variable and its value */
  EnvironmentVariable: {
    /** The variable's name */
    variable?: string;
    /** The variable's value */
    value?: string;
  };
  /** Machine profile for the test */
  MachineProfile: {
    /** The browser used for the test */
    browser: string;
    /** The data center used for the test */
    location: string;
    /** The network profile used by the test */
    network: string;
    /** The firewall profile used by the test */
    firewall: string;
    /** The media file used by this test */
    media: string;
  };
  /** A TestRun object holds a specific test execution */
  TestRun: {
    /** The unique identity of the TestRun object. Used as the key to access a test run. */
    testRunId?: string;
    /** The unique identity of the Test object. */
    testId?: string;
    /** The result status of the test. Can be 'success', 'warning' or 'failure' */
    status?: string;
    /** Can be either 'manual' or 'automated' */
    runType?: string;
    /** The number of concurrent browser agents used in this test run */
    concurrentUsers?: number;
    /** The total number of WebRTC PeerConnection sessions conducted in this test run */
    sessionSize?: number;
    /** The starting time of the test run */
    startTime?: string;
    /** (in seconds) The total duration of the test run */
    duration?: number;
    /** The list of unique test agents used in the given test run. This can either be ID values or expanded TestAgent objects, depending on which API call was made and what parameters was passed to it. */
    agents?: string[];
    /** URL of this test result */
    url?: string;
  };
  /** A TestAgent object holds the reported statistics of a specific browser agent used in a given TestRun. */
  TestAgent: {
    /** The unique identifier of a test agent used in a test run. This value is unique across the testRTC service */
    testAgentId?: string;
    /** The unique identifier of the test run this test agent was used in */
    testRunId?: string;
    /** The unique identifier of the test that was executed by this agent */
    testId?: string;
    /** The result status of the test. Can be 'success', 'warning' or 'failure' */
    status?: string;
    /** The type of the machine used by this test agent */
    machine?: string;
    /** The operating system used by this test agent */
    os?: string;
    /** The browser used by this test agent */
    browser?: {
      /** The name of the browser used */
      name: string;
      /** The exact browser version used */
      version: string;
    };
    /** The data center this test agent was running from */
    location?: string;
    /** The network profile used by this test agent */
    networkProfile?: string;
    /** The firewall profile used by this test agent */
    firewallProfile?: string;
    /** The media file used by this test agent */
    mediaFile?: string;
    /** The index of this agent within the test run. Starts from 1 */
    agentIdx?: number;
    /** The index of this agent's session within the test run. Starts from 1 */
    sessionIdx?: number;
    /** The index of this agent within the session. Starts from 1 */
    inSessionIdx?: number;
    /** The starting time of the test run */
    startTime?: string;
    /** (in seconds) The total duration of the test run */
    duration?: number;
    /** An array of custom metrics added by the customer to this agent's test results */
    customMetrics?: definitions["CustomMetrics"][];
    /** Channels created in this test run */
    channels?: definitions["Channels"][];
  };
  /** A custom metric value, provided by the customer */
  CustomMetrics: {
    /** The customer-given name for the metric. This is used as a unique identifier when aggregating metric values across a test run */
    name: string;
    /** The value of the custom metric */
    value: string;
  };
  /** A media channel in an agent's test run */
  Channels: {
    /** The name of the channel. Usually this would be the SSRC generated by the browser for the channel, if it is available */
    name: string;
    /** Can be either 'in' or 'out' */
    direction: string;
    /** Can be either 'audio' or 'video' */
    type: string;
    /** The audio or video codec used in the channel */
    codec?: string;
  };
  TestRunId: {
    testRunId: string;
  };
  TestDefinitionId: {
    testDefinitionId: string;
  };
  Error: {
    code: number;
    message: string;
  };
  BlobUploadResult: {
    fullBlobName: string;
  };
  /** GetStats data collected during remote test execution (via SDK) */
  GetStatsChunk: {
    /** GetStats data */
    data: { [key: string]: any };
    /** Indicates that the test run should be finalized after this chunk of data */
    isLastChunk?: boolean;
  };
  /** Remote test execution options */
  RemoteTestOptions: {
    /** Test name */
    name: string;
  };
  /** Network test results */
  NetworkTestData: { [key: string]: any };
  /** Network test config */
  NetworkTestConfig: { [key: string]: any };
  /** An Asset. */
  Asset: {
    /** The uniq and readable name given to the asset. */
    name: string;
    /** An asset type. */
    asset_type?: string;
    /** An asset description. */
    description?: string;
    /** Code of asset. */
    code?: string;
    /** Version of asset. */
    version: string;
  };
  /** An array holds all the assets */
  Assets: definitions["Asset"][];
  AssetId: {
    assetId: string;
  };
  /** Screenshot */
  Screenshot: {
    /** Url of screenshot. */
    url?: string;
    /** Screenshot name. */
    name?: string;
    /** Contains time when screenshot was taken and URL of the image itself. */
    metadata?: {
      /** Image URL. */
      url?: string;
      /** Time when screenshot was taken */
      timestamp?: string;
    };
  };
  /** Object holds property that holds array of screenshots */
  ScreenshotsResponse: {
    /** An array that holds screenshots */
    screens?: definitions["Screenshot"][];
  };
  /** Dial In results */
  DialInData: {
    /** callDuration */
    callDuration: number;
    /** waitTime */
    waitTime: number;
    /** pinCode */
    pinCode: string;
    /** promptTime */
    promptTime: number;
    /** mediaUrl */
    mediaUrl: string;
    /** toLocation */
    toLocation: string;
    /** fromLocation */
    fromLocation: string;
    /** account */
    account: string;
  };
  /** AnalyzeRtc authentication object */
  AnalyzeRTCAuthRequest: {
    /** Auto generated api key from the main app */
    apiKey?: string;
  };
  /** AnalyzeRtc authentication object */
  AnalyzeRTCAuthResponse: {
    /** User Ref identifier */
    userRef?: string;
    /** Urls allowed to collect data from */
    urls?: string[];
  };
  /** Docker Machine */
  DockerMachine: {
    /** Identifier */
    id?: string;
    /** Identifier */
    name?: string;
    /** Binary */
    binary?: string;
    /** Chromedriver */
    chromedriver?: string;
    /** Chromedriver */
    "image-name"?: string;
    /** Chromedriver */
    "debug-image-name"?: string;
  };
  /** Global Settings */
  GlobalSettings: {
    "docker-machines"?: definitions["DockerMachine"][];
  };
}

export interface operations {
  /** <p>List all tests in your project. This function is useful if you want to iterate overyour tests. A good example for that is when you want to collect all testId's in order to run them sequentially on your nightly build.</p> */
  getTests: {
    responses: {
      /** tests response */
      200: {
        schema: definitions["Tests"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Create a new test.</p> */
  createTest: {
    parameters: {
      body: {
        /** Test object */
        test: definitions["Test"];
      };
    };
    responses: {
      /** Test created */
      200: {
        schema: definitions["Test"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Retrieve the information of a specific test.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  findTestById: {
    parameters: {
      path: {
        /** ID of the test to fetch */
        testId: string;
      };
    };
    responses: {
      /** test response */
      200: {
        schema: definitions["TestMinimized"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Update a new test.</p> */
  updateTest: {
    parameters: {
      path: {
        /** ID of the test to update */
        testId: string;
      };
      body: {
        /** Metrics to update */
        test: definitions["Test"];
      };
    };
    responses: {
      /** Test created */
      200: {
        schema: definitions["Test"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Delete a test.</p> */
  deleteTest: {
    parameters: {
      path: {
        /** ID of the test to update */
        testId: string;
      };
    };
    responses: {
      /** Test Deleted */
      200: {
        schema: definitions["TestDefinitionId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Execute a specific test.</p><p>Once the test finishes, if a webhook is provided, the webhook will be called with the given input. To the input, a field called “testRunId” will be added, with the ID of the test run result.</p><p>The webhook's override can contain a list of key values of fields of the test that are overridden with specific values for this test. Fields that can be overridden are: concurrentUsers, iterations, runOptions, serviceUrl</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  runTestById: {
    parameters: {
      path: {
        /** ID of the test to fetch */
        testId: string;
      };
      body: {
        /** TestRunParameters */
        parameters?: definitions["TestRunParameters"];
      };
    };
    responses: {
      /** test response */
      200: {
        schema: definitions["TestRunId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Retrieve test run information.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  retrieveTestRunById: {
    parameters: {
      path: {
        /** ID of the test run to fetch */
        testRunId: string;
      };
      query: {
        /** <p>Defaults to false. If set to true, appear stats</p> */
        detailed?: boolean;
      };
    };
    responses: {
      /** test response */
      200: {
        schema: definitions["TestRun"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Retrieve report of a specific test agent information.</p><p>Each test run result is constructed out of the number of test agents used for running the test. This API retrieves the information from one specific test agent within a test run.</p><p><i>Additional fields will be returned in the future in the JSON once we model them nicely.</i></p> */
  retrieveTestAgentById: {
    parameters: {
      path: {
        /** ID of the test agent to fetch */
        testAgentId: string;
      };
      query: {
        /** <p>Defaults to false. If set to true, appear stats</p> */
        detailed?: boolean;
      };
    };
    responses: {
      /** test response */
      200: {
        schema: definitions["TestAgent"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get the test agent file</p> */
  getTestAgentFile: {
    parameters: {
      path: {
        /** ID of the test agent to fetch */
        testAgentId: string;
      };
      query: {
        /** browser_logs | webrtc_internals_dump | getstats_dump | nighwatch_log */
        filename: string;
      };
    };
    responses: {
      /** Test agent file */
      200: {
        schema: { [key: string]: any };
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Post file which will be uploaded to the test agent as part of results</p> */
  uploadFileToTestAgent: {
    parameters: {
      path: {
        /** ID of the test agent to fetch */
        testAgentId: string;
      };
      formData: {
        /** The file  to upload. */
        file?: { [key: string]: any };
      };
      query: {
        /** File name. */
        filename?: string;
      };
    };
    responses: {
      /** update response */
      200: {
        schema: definitions["CustomMetrics"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Create a new monitor.</p> */
  createMonitor: {
    parameters: {
      body: {
        /** Monitor to create */
        monitor: definitions["Monitor"];
      };
    };
    responses: {
      /** Monitor created */
      201: {
        schema: definitions["Monitor"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Update a monitor.</p> */
  updateMonitorStatus: {
    parameters: {
      path: {
        /** ID of the monitor to update */
        monitorId: string;
      };
      body: {
        /** The monitor status. Can be 'true' or 'false'. */
        data: definitions["MonitorStatus"];
      };
    };
    responses: {
      /** Monitor status is updated */
      200: unknown;
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>List all assets in your project.</p> */
  getAssets: {
    responses: {
      /** assets response */
      200: {
        schema: definitions["Assets"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Create a new asset within your project. Assets are files that can be used by your scripts. The current supported assets are scripts that can be included from your test scripts.</p><p>The asset_type must be set to 'Code'.</p> */
  createAsset: {
    parameters: {
      body: {
        /** Asset to create */
        asset: definitions["Asset"];
      };
    };
    responses: {
      /** Asset created */
      201: {
        schema: definitions["AssetId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** Bad request - Invalid parameters supplied */
      409: {
        schema: definitions["Error"];
      };
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get asset by id.</p> */
  getAsset: {
    parameters: {
      path: {
        /** ID of the previously saved asset */
        assetId: string;
      };
    };
    responses: {
      /** Asset results */
      200: {
        schema: definitions["Asset"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Update an asset within your project.</p> */
  updateAsset: {
    parameters: {
      path: {
        /** ID of the asset to update */
        assetId: string;
      };
      body: {
        /** Asset to update */
        asset: definitions["Asset"];
      };
    };
    responses: {
      /** Asset updated */
      200: {
        schema: definitions["Asset"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** Bad request - Invalid parameters supplied */
      409: {
        schema: definitions["Error"];
      };
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Delete an asset within your project.</p> */
  deleteAssetById: {
    parameters: {
      path: {
        /** ID of the asset to delete */
        assetId: string;
      };
    };
    responses: {
      /** Asset Deleted */
      200: {
        schema: definitions["AssetId"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get the screenshots taken for a specific probe (=test run agent) used in a test or a monitor execution.</p> */
  getScreenshots: {
    parameters: {
      path: {
        /** ID of the test iteration */
        testAgentId: string;
      };
    };
    responses: {
      /** List of screenshots */
      200: {
        schema: definitions["ScreenshotsResponse"];
      };
      /** Bad request */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Dial In.</p> */
  dialIn: {
    parameters: {
      body: {
        /** dial in json data */
        data: definitions["DialInData"];
      };
    };
    responses: {
      /** dial in called */
      201: {
        schema: definitions["DialInData"];
      };
      /** Bad request - Invalid parameters supplied */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /** <p>Get usage.</p> */
  getUsage: {
    responses: {
      /** Usage */
      200: {
        schema: { [key: string]: any };
      };
      /** Bad request */
      400: {
        schema: definitions["Error"];
      };
      /** Unauthorized - API key is invalid */
      401: unknown;
      /** Forbidden - Resource is not allowed */
      403: unknown;
      /** Not found - resource does not exist */
      404: unknown;
      /** unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
}
